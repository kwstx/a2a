import time
import math
from typing import List, Dict, Any, Tuple
from src.models.impact import ImpactProjection, ImpactVector, ImpactCategory, SurplusPool

class CooperativeSurplusEngine:
    """
    Computes the collective value generated by a cluster of tasks.
    Aggregates impact vectors and applies dependency-aware normalization.
    """
    
    def __init__(self, synergy_multiplier: float = 0.15, dependency_risk_factor: float = 0.05):
        self.synergy_multiplier = synergy_multiplier
        self.dependency_risk_factor = dependency_risk_factor


    def _compute_synergy_coefficient(self, projections: List[ImpactProjection], internal_deps: int) -> Tuple[float, Dict[str, float]]:
        """
        Implements non-linear synergy scaling based on cross-role diversity,
        dependency density, and contribution interdependence.
        """
        num_tasks = len(projections)
        if num_tasks <= 1:
            return 1.0, {"diversity": 1.0, "density": 0.0, "interdependence": 0.0}

        # 1. Cross-role diversity: unique roles involved
        roles = {p.metadata.get("agent_role", "unknown") for p in projections}
        diversity = len(roles) / num_tasks

        # 2. Dependency density: internal deps vs max possible
        max_possible_deps = num_tasks * (num_tasks - 1)
        density = internal_deps / max_possible_deps

        # 3. Contribution interdependence: deps per task
        interdependence = internal_deps / num_tasks

        # Non-linear scaling function:
        # Increases surplus as diversity, density, and interdependence increase.
        # Exponential growth under high structural cooperation (density).
        
        # Base multiplier from diversity and interdependence (superlinear)
        base_synergy = (diversity ** 0.4) * (1.0 + interdependence ** 1.2)
        
        # Exponential boost from structural density
        # We use a calibrated scaling factor to control growth
        exponential_boost = math.exp(density * self.synergy_multiplier * 4.0)
        
        total_synergy = round(base_synergy * exponential_boost, 4)
        
        return total_synergy, {
            "diversity": round(diversity, 4),
            "density": round(density, 4),
            "interdependence": round(interdependence, 4)
        }

    def calculate_cluster_surplus(self, cluster_id: str, projections: List[ImpactProjection]) -> SurplusPool:
        """
        Calculates the total predicted cooperative surplus for a list of projections.
        Applies non-linear synergy scaling.
        """
        if not projections:
            return SurplusPool(
                cluster_id=cluster_id,
                total_surplus=0.0,
                confidence_interval=(0.0, 0.0),
                aggregated_vectors={},
                task_ids=[]
            )

        task_ids = [p.task_id for p in projections]
        base_surplus = 0.0
        total_variance = 0.0
        
        # Aggregated vectors by category
        aggregated_magnitudes: Dict[str, float] = {}
        
        internal_dependencies = 0
        external_dependencies = 0

        for proj in projections:
            base_surplus += proj.distribution_mean
            
            # Combine variances (std^2)
            total_variance += proj.distribution_std ** 2
            
            # Aggregate vectors (first-order)
            cat_name = proj.target_vector.category.name
            aggregated_magnitudes[cat_name] = aggregated_magnitudes.get(cat_name, 0.0) + proj.target_vector.magnitude
            
            # Check dependencies
            deps = proj.target_vector.causal_dependencies
            for dep in deps:
                if dep in task_ids:
                    internal_dependencies += 1
                else:
                    external_dependencies += 1

        # Calculate Synergy Coefficient
        synergy_bonus, synergy_metrics = self._compute_synergy_coefficient(projections, internal_dependencies)
        
        # Risk: External dependencies (uncontrolled) decrease the predicted value
        risk_discount = 1.0 / (1.0 + (external_dependencies * self.dependency_risk_factor))
        
        total_surplus = round(base_surplus * synergy_bonus * risk_discount, 4)
        
        # Aggregate confidence interval
        combined_std = math.sqrt(total_variance)
        # The CI scales with the bonus/discount as well
        scaling_factor = synergy_bonus * risk_discount
        ci_width = 1.96 * combined_std * scaling_factor
        ci_low = round(total_surplus - ci_width, 4)
        ci_high = round(total_surplus + ci_width, 4)

        return SurplusPool(
            cluster_id=cluster_id,
            total_surplus=total_surplus,
            confidence_interval=(ci_low, ci_high),
            aggregated_vectors=aggregated_magnitudes,
            task_ids=task_ids,
            metadata={
                "base_surplus": round(base_surplus, 4),
                "internal_dependencies": internal_dependencies,
                "external_dependencies": external_dependencies,
                "synergy_bonus": synergy_bonus,
                "synergy_metrics": synergy_metrics,
                "risk_discount": round(risk_discount, 4),
                "effective_multiplier": round(scaling_factor, 4)
            }
        )

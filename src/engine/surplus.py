import time
import math
from typing import List, Dict, Any, Tuple
from src.models.impact import ImpactProjection, ImpactVector, ImpactCategory, SurplusPool, ContributionClaim

class CooperativeSurplusEngine:
    """
    Computes the collective value generated by a cluster of tasks.
    Aggregates impact vectors and applies dependency-aware normalization.
    """
    
    def __init__(self, synergy_multiplier: float = 0.15, dependency_risk_factor: float = 0.05):
        self.synergy_multiplier = synergy_multiplier
        self.dependency_risk_factor = dependency_risk_factor


    def _compute_synergy_coefficient(self, projections: List[ImpactProjection], internal_deps: int) -> Tuple[float, Dict[str, float]]:
        """
        Implements non-linear synergy scaling based on cross-role diversity,
        dependency density, and contribution interdependence.
        """
        num_tasks = len(projections)
        if num_tasks <= 1:
            return 1.0, {"diversity": 1.0, "density": 0.0, "interdependence": 0.0}

        # 1. Cross-role diversity: unique roles involved
        roles = {p.metadata.get("agent_role", "unknown") for p in projections}
        diversity = len(roles) / num_tasks

        # 2. Dependency density: internal deps vs max possible
        max_possible_deps = num_tasks * (num_tasks - 1)
        density = internal_deps / max_possible_deps

        # 3. Contribution interdependence: deps per task
        interdependence = internal_deps / num_tasks

        # Non-linear scaling function:
        # Increases surplus as diversity, density, and interdependence increase.
        # Exponential growth under high structural cooperation (density).
        
        # Base multiplier from diversity and interdependence (superlinear)
        base_synergy = (diversity ** 0.4) * (1.0 + interdependence ** 1.2)
        
        # Exponential boost from structural density
        # We use a calibrated scaling factor to control growth
        exponential_boost = math.exp(density * self.synergy_multiplier * 4.0)
        
        total_synergy = round(base_synergy * exponential_boost, 4)
        
        return total_synergy, {
            "diversity": round(diversity, 4),
            "density": round(density, 4),
            "interdependence": round(interdependence, 4)
        }

    def calculate_cluster_surplus(self, cluster_id: str, projections: List[ImpactProjection]) -> SurplusPool:
        """
        Calculates the total predicted cooperative surplus for a list of projections.
        Applies non-linear synergy scaling.
        """
        if not projections:
            return SurplusPool(
                cluster_id=cluster_id,
                total_surplus=0.0,
                confidence_interval=(0.0, 0.0),
                aggregated_vectors={},
                task_ids=[]
            )

        task_ids = [p.task_id for p in projections]
        base_surplus = 0.0
        total_variance = 0.0
        
        # Aggregated vectors by category
        aggregated_magnitudes: Dict[str, float] = {}
        
        internal_dependencies = 0
        external_dependencies = 0

        for proj in projections:
            base_surplus += proj.distribution_mean
            
            # Combine variances (std^2)
            total_variance += proj.distribution_std ** 2
            
            # Aggregate vectors (first-order)
            cat_name = proj.target_vector.category.name
            aggregated_magnitudes[cat_name] = aggregated_magnitudes.get(cat_name, 0.0) + proj.target_vector.magnitude
            
            # Check dependencies
            deps = proj.target_vector.causal_dependencies
            for dep in deps:
                if dep in task_ids:
                    internal_dependencies += 1
                else:
                    external_dependencies += 1

        # Calculate Synergy Coefficient
        synergy_bonus, synergy_metrics = self._compute_synergy_coefficient(projections, internal_dependencies)
        
        # Risk: External dependencies (uncontrolled) decrease the predicted value
        risk_discount = 1.0 / (1.0 + (external_dependencies * self.dependency_risk_factor))
        
        total_surplus = round(base_surplus * synergy_bonus * risk_discount, 4)
        
        # Aggregate confidence interval
        combined_std = math.sqrt(total_variance)
        # The CI scales with the bonus/discount as well
        scaling_factor = synergy_bonus * risk_discount
        ci_width = 1.96 * combined_std * scaling_factor
        ci_low = round(total_surplus - ci_width, 4)
        ci_high = round(total_surplus + ci_width, 4)

        return SurplusPool(
            cluster_id=cluster_id,
            total_surplus=total_surplus,
            confidence_interval=(ci_low, ci_high),
            aggregated_vectors=aggregated_magnitudes,
            task_ids=task_ids,
            metadata={
                "base_surplus": round(base_surplus, 4),
                "internal_dependencies": internal_dependencies,
                "external_dependencies": external_dependencies,
                "synergy_bonus": synergy_bonus,
                "synergy_metrics": synergy_metrics,
                "risk_discount": round(risk_discount, 4),
                "effective_multiplier": round(scaling_factor, 4)
            }
        )

    def estimate_marginal_contributions(self, cluster_id: str, projections: List[ImpactProjection]) -> List[ContributionClaim]:
        """
        Computes predicted marginal contribution for each participating agent
        using counterfactual modeling (simulating V(All) vs V(All - agent)).
        """
        if not projections:
            return []

        # Baseline surplus with all agents
        baseline_pool = self.calculate_cluster_surplus(cluster_id, projections)
        baseline_v = baseline_pool.total_surplus
        baseline_synergy = baseline_pool.metadata["synergy_bonus"]
        baseline_ci_width = baseline_pool.confidence_interval[1] - baseline_pool.confidence_interval[0]

        # Map agents to their projections
        agent_projections: Dict[str, List[ImpactProjection]] = {}
        for proj in projections:
            agent_id = proj.metadata.get("agent_id", "unknown_agent")
            if agent_id not in agent_projections:
                agent_projections[agent_id] = []
            agent_projections[agent_id].append(proj)

        claims = []
        for agent_id, a_projs in agent_projections.items():
            # Counterfactual: Surplus WITHOUT this agent's involvement
            remaining_projections = [p for p in projections if p.metadata.get("agent_id") != agent_id]
            
            if not remaining_projections:
                # If this was the only agent, their marginal contribution is the total surplus
                marginal_impact = baseline_v
                uncertainty_margin = baseline_ci_width
                dependency_weight = 1.0
            else:
                counterfactual_pool = self.calculate_cluster_surplus(cluster_id, remaining_projections)
                
                # Marginal Impact = V(All) - V(All - agent)
                marginal_impact = max(0.0, round(baseline_v - counterfactual_pool.total_surplus, 4))
                
                # Uncertainty Margin: How much they added to the predictive spread
                cf_ci_width = counterfactual_pool.confidence_interval[1] - counterfactual_pool.confidence_interval[0]
                uncertainty_margin = round(abs(baseline_ci_width - cf_ci_width), 4)
                
                # Dependency Influence Weight: Ratio of synergy change
                # Measures how much this agent's presence boosted the collective multiplier
                if counterfactual_pool.metadata["synergy_bonus"] > 0:
                    synergy_ratio = baseline_synergy / counterfactual_pool.metadata["synergy_bonus"]
                else:
                    synergy_ratio = 1.0
                
                # Normalized weight (capped/focused on contribution to synergy)
                dependency_weight = round(min(1.0, max(0.0, synergy_ratio - 1.0)), 4)

            claims.append(ContributionClaim(
                agent_id=agent_id,
                cluster_id=cluster_id,
                marginal_impact_estimate=marginal_impact,
                uncertainty_margin=uncertainty_margin,
                dependency_influence_weight=dependency_weight,
                task_ids=[p.task_id for p in a_projs],
                metadata={
                    "counterfactual_surplus": counterfactual_pool.total_surplus if remaining_projections else 0.0,
                    "synergy_contribution": round(baseline_synergy - (counterfactual_pool.metadata["synergy_bonus"] if remaining_projections else 1.0), 4)
                }
            ))

        return claims
